<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>index (opium_core.index)</title><link rel="stylesheet" href="../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ opium_core</nav><nav class="toc"><ul><li><a href="#opium-core">Opium Core</a><ul><li><a href="#services">Services</a></li><li><a href="#filters">Filters</a></li></ul></li></ul></nav></header><h2 id="opium-core"><a href="#opium-core" class="anchor"></a>Opium Core</h2><p>The core pieces provided by <code>Opium_core</code> are Services and Filter.</p><h3 id="services"><a href="#services" class="anchor"></a>Services</h3><p>Services are simple functions with the following type:</p><pre><code class="ml">type ('req, 'res) t = 'req -&gt; 'res Lwt.t</code></pre><p>They take a request of type <code>'req</code> and return a <a href="https://ocsigen.org/lwt/4.3.0/manual/manual">Lwt</a> promise, a reference that will eventually be filled asynchronously with the result of type <code>'res</code>.</p><p>An example of a simple service that takes an integer and returns a string promise:</p><pre><code class="ml">let my_simple_service : (int, string) Service.t =
  fun request -&gt; Lwt.return (string_of_int request)
;;</code></pre><p>The type signature is shown just for demonstration purpose for the example.</p><p>Services can also be used to represent an HTTP handler if they work with an HTTP request and return a promise that will be filled by its response.</p><pre><code class="ml">let http_service : (Cohttp.Request.t, Cohttp.Response.t * Cohttp_lwt.Body.t)
  = Lwt.return (...)
;;</code></pre><h3 id="filters"><a href="#filters" class="anchor"></a>Filters</h3><p>Filters are defined by the type:</p><pre><code class="ml">type ('req, 'res, 'req', 'res') t
  = ('req, 'res) Service.t -&gt; ('req', 'res') Service.t</code></pre><p>Filters are simple functions that can be used to transform a service. Given a service of type <code>('req, 'res) Service.t</code> a filter can modify it to a new service that will respond with a type of <code>'res'</code>. But in simple scenario a filter can be used to just perform some operations on a given service while keeping the same types for request and response. In such scenarios a filter represent by the type:</p><pre><code class="ml">type ('req, 'res) simple = ('req, 'res) Service.t -&gt; ('req, 'res) Service.t</code></pre><p>Example: We can define a new filter which can transform the <code>my_simple_service</code> defined above by tweaking the incoming integer <code>request</code> by adding 2 to it, before forwarding it to the original service.</p><pre><code class="ml">let add_two_filter : (int, string) Filter.simple =
  fun service req -&gt; service (req + 2)
;;

(* Applying the filter to get a new service *)
let new_service = add_two_filter my_simple_service;;

(* Using the new service to get results. This will return a Lwt promise that'll eventually be filled with &quot;14&quot; *)
new_service 12;;
- : string = &quot;14&quot;</code></pre><p>There is a shortcut to apply a collection of simple filters to a given service.</p><pre><code class="ml">let new_service = Filter.apply_all [add_two_filter; add_two_filter; add_two_filter] my_simple_service;;

(* If we call our new service with the number 12 now, we'll get a promise that'll eventually be filled with &quot;18&quot; *)
new_service 12;;
- : string = &quot;18&quot;</code></pre></div></body></html>